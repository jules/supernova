//! A collection of structures generated by the [`ProvingAssignment`] constraint system,
//! used for the SuperNova protocol when instantiated on R1CS circuits.

use super::StepCircuit;
use crate::{commit, Arithmetization};
use ark_bls12_381::{Config as Bls12Config, Fq, G1Projective};
use ark_crypto_primitives::sponge::{
    constraints::CryptographicSpongeVar,
    poseidon::{constraints::PoseidonSpongeVar, PoseidonConfig, PoseidonSponge},
    CryptographicSponge, FieldBasedCryptographicSponge,
};
use ark_ec::Group;
use ark_ff::{One, PrimeField, Zero};
use ark_r1cs_std::{
    alloc::AllocVar,
    boolean::Boolean,
    eq::EqGadget,
    fields::fp::FpVar,
    groups::{curves::short_weierstrass::bls12::G1Var, CurveVar},
    select::CondSelectGadget,
    R1CSVar, ToBitsGadget, ToConstraintFieldGadget,
};
use ark_relations::r1cs::{ConstraintMatrices, ConstraintSystem, ConstraintSystemRef};
use ark_serialize::CanonicalSerialize;
use core::ops::{Add, Mul};
use itertools::concat;
use rayon::prelude::*;

#[derive(CanonicalSerialize)]
pub struct SerializableShape {
    num_vars: usize,
    num_public_inputs: usize,
    A: Vec<Vec<Fq>>,
    B: Vec<Vec<Fq>>,
    C: Vec<Vec<Fq>>,
}

impl From<ConstraintMatrices<Fq>> for SerializableShape {
    fn from(v: ConstraintMatrices<Fq>) -> Self {
        let convert_matrix = |m: &[Vec<(Fq, usize)>]| -> Vec<Vec<Fq>> {
            m.iter()
                .map(|row| row.iter().map(|(coeff, _var)| *coeff).collect::<Vec<Fq>>())
                .collect::<Vec<Vec<Fq>>>()
        };

        Self {
            num_vars: v.num_witness_variables,
            num_public_inputs: v.num_instance_variables,
            A: convert_matrix(&v.a),
            B: convert_matrix(&v.b),
            C: convert_matrix(&v.c),
        }
    }
}

impl SerializableShape {
    fn digest(&self, constants: &PoseidonConfig<Fq>) -> Fq {
        let mut bytes = vec![];
        self.serialize_compressed(&mut bytes).unwrap();

        let mut sponge = PoseidonSponge::<Fq>::new(constants);
        sponge.absorb(&bytes);
        sponge.squeeze_native_field_elements(1)[0]
    }
}

#[allow(clippy::type_complexity)]
fn multiply_vec(
    a: &[Vec<(Fq, usize)>],
    b: &[Vec<(Fq, usize)>],
    c: &[Vec<(Fq, usize)>],
    z: &[Fq],
) -> (Vec<Fq>, Vec<Fq>, Vec<Fq>) {
    if z.len() != a.len() {
        // TODO: shouldnt panic here
        panic!("mismatched inputs to shape");
    }

    let sparse_matrix_vec_product = |m: &[Vec<(Fq, usize)>], z: &[Fq]| -> Vec<Fq> {
        m.par_iter()
            .map(|row| {
                row.par_iter()
                    .zip(z)
                    .fold(Fq::zero, |acc, ((coeff, val), v)| {
                        acc + coeff * &Fq::from(*val as u64) * v
                    })
                    .reduce(Fq::zero, |acc, val| acc + val)
            })
            .collect::<Vec<Fq>>()
    };

    let (Az, (Bz, Cz)) = rayon::join(
        || sparse_matrix_vec_product(a, z),
        || {
            rayon::join(
                || sparse_matrix_vec_product(b, z),
                || sparse_matrix_vec_product(c, z),
            )
        },
    );

    (Az, Bz, Cz)
}

#[derive(Clone)]
pub struct R1CS<C: StepCircuit<Fq>> {
    pub(crate) shape: ConstraintMatrices<Fq>,
    pub(crate) comm_witness: G1Projective,
    pub(crate) comm_E: G1Projective,
    pub(crate) comm_T: G1Projective,
    pub(crate) E: Vec<Fq>,
    pub(crate) witness: Vec<Fq>,
    pub(crate) instance: Vec<Fq>,
    pub(crate) u: Fq,
    pub(crate) hash: Fq,
    pub(crate) output: Vec<Fq>,
    pub(crate) circuit: C,
}

impl<C: StepCircuit<Fq>> R1CS<C> {
    fn commit_t(&self, other: &Self, generators: &[G1Projective]) -> (Vec<Fq>, G1Projective) {
        let (az1, bz1, cz1) = multiply_vec(
            &self.shape.a,
            &self.shape.b,
            &self.shape.c,
            &[self.witness.as_slice(), &[self.u], self.instance.as_slice()].concat(),
        );
        let (az2, bz2, cz2) = multiply_vec(
            &self.shape.a,
            &self.shape.b,
            &self.shape.c,
            &[
                other.witness.as_slice(),
                &[other.u],
                other.instance.as_slice(),
            ]
            .concat(),
        );

        let t = az1
            .into_iter()
            .zip(bz2)
            .zip(az2)
            .zip(bz1)
            .zip(cz1)
            .zip(cz2)
            .map(|(((((az1, bz2), az2), bz1), cz1), cz2)| {
                az1 * bz2 + az2 * bz1 - self.u * cz2 - cz1
            })
            .collect::<Vec<Fq>>();
        let comm_T = commit(generators, &t);
        (t.to_vec(), comm_T)
    }

    #[allow(clippy::type_complexity)]
    fn alloc_witnesses(
        &self,
        params: Fq,
        cs: &mut ConstraintSystemRef<Fq>,
        i: usize,
    ) -> (
        FpVar<Fq>,
        FpVar<Fq>,
        Vec<FpVar<Fq>>,
        Vec<FpVar<Fq>>,
        G1Var<Bls12Config>,
        G1Var<Bls12Config>,
        FpVar<Fq>,
        FpVar<Fq>,
        G1Var<Bls12Config>,
    ) {
        let params = FpVar::<_>::new_witness(cs.clone(), || Ok(params)).unwrap();
        let i = FpVar::<_>::new_witness(cs.clone(), || Ok(Fq::from(i as u64))).unwrap();
        let z0 = self
            .z0()
            .iter()
            .map(|v| FpVar::<_>::new_witness(cs.clone(), || Ok(v)).unwrap())
            .collect::<Vec<_>>();
        let output = self
            .output()
            .iter()
            .map(|v| FpVar::<_>::new_witness(cs.clone(), || Ok(v)).unwrap())
            .collect::<Vec<_>>();
        let comm_W =
            G1Var::<Bls12Config>::new_witness(cs.clone(), || Ok(self.comm_witness)).unwrap();
        let comm_E = G1Var::<Bls12Config>::new_witness(cs.clone(), || Ok(self.comm_E)).unwrap();
        let u = FpVar::<Fq>::new_witness(cs.clone(), || Ok(self.u)).unwrap();
        let hash = FpVar::<Fq>::new_witness(cs.clone(), || Ok(self.hash)).unwrap();
        let comm_T = G1Var::<Bls12Config>::new_witness(cs.clone(), || Ok(self.comm_T)).unwrap();
        (params, i, z0, output, comm_W, comm_E, u, hash, comm_T)
    }
}

impl<C: StepCircuit<Fq>> Arithmetization for R1CS<C> {
    type ConstraintSystem = ConstraintSystemRef<Fq>;

    fn hash(&self) -> Fq {
        self.hash
    }

    fn witness_commitment(&self) -> G1Projective {
        self.comm_witness
    }

    fn is_satisfied(&self, generators: &[G1Projective]) -> bool {
        let num_constraints = self.shape.a.len();
        if self.witness.len() != self.shape.num_witness_variables
            || self.E.len() != num_constraints
            || self.instance.len() != self.shape.num_instance_variables
        {
            return false;
        }

        // Verify if az * bz = u*cz + E.
        let z = concat(vec![
            self.witness.clone(),
            vec![self.u],
            self.instance.clone(),
        ]);
        let (az, bz, cz) = multiply_vec(&self.shape.a, &self.shape.b, &self.shape.c, &z);
        if az.len() != num_constraints || bz.len() != num_constraints || cz.len() != num_constraints
        {
            return false;
        }

        if (0..num_constraints).any(|i| az[i] * bz[i] != self.u * cz[i] + self.E[i]) {
            return false;
        }

        // Verify if comm_E and comm_witness are commitments to E and witness.
        let comm_witness = commit(generators, &self.witness);
        let comm_E = commit(generators, &self.E);
        self.comm_witness == comm_witness && self.comm_E == comm_E
    }

    fn is_zero(&self) -> bool {
        self.witness.iter().all(|v| v.is_zero()) && self.instance.iter().all(|v| v.is_zero())
    }

    fn output(&self) -> &[Fq] {
        &self.output
    }

    fn params(&self) -> Fq {
        Fq::from(self.shape.a.len() as u64) + Fq::from(self.shape.num_witness_variables as u64)
    }

    fn has_crossterms(&self) -> bool {
        self.E.iter().any(|v| !v.is_zero()) && self.u != Fq::one()
    }

    fn z0(&self) -> Vec<Fq> {
        vec![Fq::zero(); self.shape.num_instance_variables]
    }

    fn synthesize(
        &mut self,
        params: Fq,
        latest_witness: G1Projective,
        latest_hash: Fq,
        old_pc: usize,
        new_pc: usize,
        i: usize,
        constants: &PoseidonConfig<Fq>,
        generators: &[G1Projective],
    ) -> R1CS<C> {
        // TODO: program counter should be calculated in circuit, for now it's just supplied by
        // user
        let mut cs = ConstraintSystemRef::<Fq>::new(ConstraintSystem::new());
        let old_pc = FpVar::<Fq>::new_witness(cs.clone(), || Ok(Fq::from(old_pc as u64))).unwrap();
        let new_pc = FpVar::<Fq>::new_witness(cs.clone(), || Ok(Fq::from(new_pc as u64))).unwrap();

        let (params, i, z0, output, comm_W, comm_E, u, hash, T) =
            self.alloc_witnesses(params, &mut cs, i);
        let latest_witness =
            G1Var::<Bls12Config>::new_witness(cs.clone(), || Ok(latest_witness)).unwrap();
        let latest_hash = FpVar::<Fq>::new_witness(cs.clone(), || Ok(latest_hash)).unwrap();

        let zero = FpVar::<_>::new_witness(cs.clone(), || Ok(Fq::zero())).unwrap();
        let is_base_case = FpVar::<_>::is_eq(&i, &zero).unwrap();

        // Synthesize both cases
        // Base case
        let W_base =
            G1Var::<Bls12Config>::new_witness(cs.clone(), || Ok(G1Projective::default())).unwrap();
        let E_base =
            G1Var::<Bls12Config>::new_witness(cs.clone(), || Ok(G1Projective::default())).unwrap();
        let u_base = FpVar::<_>::new_witness(cs.clone(), || Ok(Fq::one())).unwrap();
        let hash_base = FpVar::<_>::new_witness(cs.clone(), || Ok(Fq::zero())).unwrap();

        // Non base case
        let non_base_case = FpVar::<_>::is_eq(&hash, &hash_base).unwrap();
        let hash = compute_io_hash(
            constants, &mut cs, &params, &i, &old_pc, &z0, &output, &comm_W, &comm_E, &u, &hash,
        );

        // Fold in circuit
        // Compute r
        let r = compute_r(
            constants,
            &mut cs,
            &params,
            &comm_W,
            &comm_E,
            &u,
            &hash,
            &latest_witness,
            &latest_hash,
            &T,
        );

        let rW = latest_witness
            .scalar_mul_le(r.to_bits_le().unwrap().iter())
            .unwrap();
        let W_fold = comm_W.add(&rW);

        let rT = T.scalar_mul_le(r.to_bits_le().unwrap().iter()).unwrap();
        let E_fold = comm_E.add(&rT);

        let u_fold = u.add(&r);

        // Fold IO
        let r_hash = latest_hash.mul(&r);
        let hash_fold = hash.add(&r_hash);

        // Pick new variables
        Boolean::<_>::enforce_not_equal(&is_base_case, &non_base_case).unwrap();

        let W_new =
            G1Var::<Bls12Config>::conditionally_select(&is_base_case, &W_base, &W_fold).unwrap();
        let E_new =
            G1Var::<Bls12Config>::conditionally_select(&is_base_case, &E_base, &E_fold).unwrap();
        let u_new = FpVar::<_>::conditionally_select(&is_base_case, &u_base, &u_fold).unwrap();
        let hash_new =
            FpVar::<_>::conditionally_select(&is_base_case, &hash_base, &hash_fold).unwrap();

        let i_new =
            FpVar::<_>::new_witness(cs.clone(), || Ok(i.value().unwrap() + Fq::one())).unwrap();

        let new_input = output
            .iter()
            .zip(&z0)
            .map(|(v_output, v_0)| {
                FpVar::<_>::conditionally_select(&is_base_case, v_0, v_output).unwrap()
            })
            .collect::<Vec<FpVar<Fq>>>();

        let output = self
            .circuit
            .clone()
            .generate_constraints(cs.clone(), &new_input)
            .expect("should be able to synthesize step circuit");

        // Set the new output for later use.
        self.output = output
            .iter()
            .map(|v| v.value().unwrap())
            .collect::<Vec<Fq>>();

        // Compute hash and set as output.
        let hash = FpVar::<_>::new_input(cs.clone(), || {
            Ok(compute_io_hash(
                constants, &mut cs, &params, &i_new, &new_pc, &z0, &output, &W_new, &E_new, &u_new,
                &hash_new,
            )
            .value()
            .unwrap())
        })
        .unwrap();

        // Set the new hash for later use.
        self.hash = hash.value().unwrap();
        create_circuit(cs, generators, hash.value().unwrap(), self.circuit.clone())
    }

    fn fold(&mut self, other: &Self, constants: &PoseidonConfig<Fq>, generators: &[G1Projective]) {
        let (t, comm_T) = self.commit_t(other, generators);
        let mut sponge = PoseidonSponge::<Fq>::new(constants);
        sponge.absorb(
            &[SerializableShape::from(self.shape.clone()).digest(constants)]
                .into_iter()
                .chain(self.instance.clone())
                .chain(other.instance.clone())
                .chain(t.clone())
                .collect::<Vec<Fq>>(),
        );
        let r = sponge.squeeze_native_field_elements(1)[0];
        self.witness
            .par_iter_mut()
            .zip(&other.witness)
            .for_each(|(w1, w2)| *w1 += *w2 * r);
        self.instance
            .par_iter_mut()
            .zip(&other.instance)
            .for_each(|(x1, x2)| *x1 += *x2 * r);
        self.comm_witness += other.comm_witness.mul_bigint(r.into_bigint());
        self.E.par_iter_mut().zip(t).for_each(|(a, b)| *a += r * b);
        self.comm_E += comm_T.mul_bigint(r.into_bigint());
        self.u += r;
        self.comm_T = comm_T;
    }
}

fn create_circuit<C: StepCircuit<Fq>>(
    cs: ConstraintSystemRef<Fq>,
    generators: &[G1Projective],
    hash: Fq,
    circuit: C,
) -> R1CS<C> {
    let cs = cs.into_inner().unwrap();
    let matrices = cs.to_matrices().unwrap();
    R1CS {
        shape: matrices.clone(),
        comm_witness: commit(generators, &cs.witness_assignment),
        comm_E: G1Projective::zero(),
        comm_T: G1Projective::zero(),
        E: vec![Fq::zero(); matrices.num_constraints],
        witness: cs.witness_assignment.clone(),
        instance: cs.instance_assignment.clone(),
        u: Fq::one(),
        hash,
        output: vec![],
        circuit,
    }
}

#[allow(clippy::too_many_arguments)]
fn compute_io_hash(
    constants: &PoseidonConfig<Fq>,
    cs: &mut ConstraintSystemRef<Fq>,
    params: &FpVar<Fq>,
    i: &FpVar<Fq>,
    pc: &FpVar<Fq>,
    z0: &[FpVar<Fq>],
    output: &[FpVar<Fq>],
    comm_W: &G1Var<Bls12Config>,
    comm_E: &G1Var<Bls12Config>,
    u: &FpVar<Fq>,
    hash: &FpVar<Fq>,
) -> FpVar<Fq> {
    let mut sponge = PoseidonSpongeVar::<Fq>::new(cs.clone(), constants);
    sponge.absorb(&params).unwrap();
    sponge.absorb(&i).unwrap();
    sponge.absorb(&pc).unwrap();
    z0.iter().for_each(|v| sponge.absorb(v).unwrap());
    output.iter().for_each(|v| sponge.absorb(v).unwrap());
    sponge
        .absorb(&comm_W.to_constraint_field().unwrap())
        .unwrap();
    sponge
        .absorb(&comm_E.to_constraint_field().unwrap())
        .unwrap();
    sponge.absorb(&u).unwrap();
    sponge.absorb(&hash).unwrap();
    sponge.squeeze_field_elements(1).unwrap().remove(0)
}

#[allow(clippy::too_many_arguments)]
fn compute_r(
    constants: &PoseidonConfig<Fq>,
    cs: &mut ConstraintSystemRef<Fq>,
    params: &FpVar<Fq>,
    comm_W: &G1Var<Bls12Config>,
    comm_E: &G1Var<Bls12Config>,
    u: &FpVar<Fq>,
    hash: &FpVar<Fq>,
    latest_witness: &G1Var<Bls12Config>,
    latest_hash: &FpVar<Fq>,
    T: &G1Var<Bls12Config>,
) -> FpVar<Fq> {
    let mut sponge = PoseidonSpongeVar::<Fq>::new(cs.clone(), constants);
    sponge.absorb(params).unwrap();
    sponge
        .absorb(&comm_W.to_constraint_field().unwrap())
        .unwrap();
    sponge
        .absorb(&comm_E.to_constraint_field().unwrap())
        .unwrap();
    sponge.absorb(u).unwrap();
    sponge.absorb(hash).unwrap();
    sponge
        .absorb(&latest_witness.to_constraint_field().unwrap())
        .unwrap();
    sponge.absorb(latest_hash).unwrap();
    sponge.absorb(&T.to_constraint_field().unwrap()).unwrap();
    sponge.squeeze_field_elements(1).unwrap().remove(0)
}
